* bagman (le bagnard)
*
* Z80
* disassembled by JOTD in 2010 (never too late for a good job!!)
*
 * 554C:	 0 no guard collision
* 131B 00 C3 27 13 no timer death
* wp 6025,1,w :	 watchpoints

*  guard sees right:	$80, left $40, up $10, down $20

* todo:	 find the "guard stuck" monitoring routine that resets guard at the third screen:	block the guards at 3rd screen to see!
* gameplay_allowed_6054:	if 0, cannot do anything. pressing start sets to 1:	 unimportant for the game
* elevator_y_current_screen_6587:
* elevator_dir_current_screen_6010:	 direction shared by both elevators:	1 up, 0 down
* elevator_not_moving_6012:	 0 moving:	 characters cannot move, 1 not moving
* the elevator direction and elevator floor timer are shared by both elevators
* the master being the one of the current screen or the one from screen 2
* if player is on screen 1
* elevator not in player screen does not move until in player screen!!!
* this explains the strange elevator behavior. This is deliberate and allows
* for instance to fetch the bags of screen 2 while using the elevator from
* screen 3. By timing it wisely, one can avoid the "go down bug"
* also explains that the guards never wait for an elevator when not in player
* screen:	 they could wait forever since it's not moving!!!!

*  1A0B:	 A.I. for branch with player/guard screen different

* xy <-> logical address conversions (Python proto code)
*def xy2addr(x,y,current_screen):
*     rval = 0x4062 + 0x400 * current_screen + y/8 + ((0xE0-x)/8)*0x20
*     return rval
*def addr2xy(addr):
*     b = addr - 0x4000
*     current_screen = 0
*     while b < 0x400:
*	b-=0x400
*	current_screen+=1
*     b -= 0x62
*     y = (b % 0x20) * 8
*     x = 0xE0 - b / 4
*     return [x,y,current_screen]

*tables:
*2CD3:	guard elevator waiting point table
*5974:	guard path branch address table
*5A10:	guard screen 1 => screen 2 (3 bytes/entry)
*5A3D:	guard screen 2 => screen 1 (3 bytes/entry)
*5A76:	guard screen 2 => screen 3 (3 bytes/entry)
*5AAF:	guard screen 3 => screen 2 (there's a buggy/useless value in this table)
*address is a grid with a 8x8 resolution

 * guard move clocks:	 5A4
 * player move clocks 4E4

  * debug part 1A20

*  from MAME drover
* memory map:
*
* 0000-5fff ROM
* 6000-67ff RAM
* 9000-93ff Video RAM
* 9800-9bff Color RAM
* 9800-981f Sprites (hidden portion of color RAM)
* 9c00-9fff ? (filled with 3f, not used otherwise)
* c000-ffff ROM (Super Bagman only)
*
* memory mapped ports:
*
* read:
* a000      PAL16r6 output. (RD4 line)
* a800      ? (read only in one place, not used) (RD5 line)
* b000      DSW (RD6 line)
* b800      watchdog reset (RD7 line)
*
* write:
* a000      interrupt enable
* a001      horizontal flip
* a002      vertical flip
* a003      video enable, not available on earlier hardware revision(s)
* a004      coin counter
* a007      ? /SCS line in the schems connected to AY8910 pin A4 or AA (schems are unreadable)
*
* a800-a805 these lines control the state machine driving TMS5110 (only bit 0 matters)
*           a800,a801,a802 - speech roms BIT select (000 bit 7, 001 bit 4, 010 bit 2)
*           a803 - 0 keeps the state machine in reset state; 1 starts speech
*           a804 - connected to speech rom 11 (QS) chip enable
*           a805 - connected to speech rom 12 (QT) chip enable
* b000      ?
* b800      ?

    .global bagman_irq
    .global bagman_reset

	*.include	"bagman.inc"
	.ifdef	__amiga__
	.include "bagman_ram.68k"
	.align	2
	.endif


	.macro CLEAR_XC_FLAG
	moveq	#0,d7
	roxl.b	#1,d7
	.endm
	.macro SET_XC_FLAG
	st	d7
	roxl.b	#1,d7
	.endm


* < A0: source (HL)
* < A1: destination (DE)
* < D1: length (16 bit)
ldir:
    subq.w    #1,d1
0:
    move.b    (a0)+,(a1)+
    dbf        d1,0b
    clr.w    d1
    rts

* < A0: source (HL)
* < D1: length to search
* > D0.B value searched for (A)
* > Z flag if found
cpir:
    subq.w    #1,d1
0:
    cmp.b    (a0)+,d0
    beq.b    1f
    dbf        d1,0b
    clr.w    d1
    * not found: unset Z
    cmp.b   #1,d1
1:
    rts

*---------------

assert_failed_blitz:
	jbra		osd_break
	
bagman_irq:
	
	
bagman_reset:
	* default: 1 update/irq call
	* we need 60 updates / second so on amiga PAL
	* we need to set this variable to 2 once out of 5 calls
	move.b	#1,vb_ticks_count

	jra	l_1200                             	| [$0000: jp   $1200]






* global init
l_1200:
	clr.b	d0                               	| [$1200: xor  a]
	jbsr	osd_disable_vblank_interrupt
	addq.b	#1,d0                           	| [$1205: inc  a]
	jra	l_2480                             	| [$1206: jp   $2480]

l_2480:
	jra	l_29cb                             	| [$2480: jp   $29CB]
l_2483:
	jra	l_29dc                             	| [$2483: jp   $29DC]

l_2486:
	*ld   sp,unknown_67F0
	move.b	#0x3F,d0                        	| [$2489: ld   a,$3F]
	jbsr	l_29ec                            	| [$248b: call $29EC]
	jbsr	l_2a00                            	| [$248e: call $2A00]
*	move.b	#0x01,d0                        	| [$2491: ld   a,$01]
*	move.b	d0,0xA003                       	| [$2493: ld   ($A003),a]
	lea	game_mem+0x3696,a0                      	| [$2496: ld   hl,$3696]
	lea	unknown_6217,a1                	| [$2499: ld   de,unknown_6217]
										| [$249c: ld   bc,$0050] 80
	move.w	#0x50,d1                        	| [$249c: ld   bc,$0050] 80
	jbsr	ldir                              	| [$249f: ldir]
	jra	l_121c                             	| [$24a1: jp   $121C]
l_24a4:
	move.b	unknown_6210,d0                 	| [$24a4: ld   a,(unknown_6210)]
	cmp.b	#0x01,d0                         	| [$24a7: cp   $01]
	jne	l_24e9                             	| [$24a9: jr   nz,$24E9]
	move.b	unknown_626D,d0                 	| [$24ab: ld   a,(unknown_626D)]
	cmp.b	#0x20,d0                         	| [$24ae: cp   $20]
	bcc.b	0f
	jbsr	l_24bd                            	| [$24b0: call c,$24BD]
0:
	cmp.b	#0x30,d0                         	| [$24b3: cp   $30]
	bcc.b	0f
	jbsr	l_24f2                            	| [$24b5: call c,$24F2]
0:
	clr.b	d0                               	| [$24b8: xor  a]
	move.b	d0,unknown_626D                 	| [$24b9: ld   (unknown_626D),a]
	rts                                    	| [$24bc: ret]
l_24bd:
	move.b	unknown_626E,d0                 	| [$24bd: ld   a,(unknown_626E)]
	cmp.b	#0x01,d0                         	| [$24c0: cp   $01]
	jeq	l_24d7                             	| [$24c2: jr   z,$24D7]
	jbsr	get_XUP_screen_address_2501                            	| [$24c4: call $2501]
	jeq	l_24d9                             	| [$24c7: jr   z,$24D9]
	lea	game_mem+0x575A,a1                      	| [$24c9: ld   de,$575A]
	jbsr	l_30f9                            	| [$24cc: call $30F9]
	jbsr	l_24e9                            	| [$24cf: call $24E9]
	move.b	#0x01,d0                        	| [$24d2: ld   a,$01]
	move.b	d0,unknown_626E                 	| [$24d4: ld   (unknown_626E),a]
l_24d7:
	move.w	(sp)+,d0                        	| [$24d7: pop  af]
	rts                                    	| [$24d8: ret]
l_24d9:
	lea	l_5763(pc),a1                      	| [$24d9: ld   de,$5763]
	jbsr	l_30f9                            	| [$24dc: call $30F9]
	jbsr	l_24e9                            	| [$24df: call $24E9]
	move.b	#0x01,d0                        	| [$24e2: ld   a,$01]
	move.b	d0,unknown_626E                 	| [$24e4: ld   (unknown_626E),a]
	move.w	(sp)+,d0                        	| [$24e7: pop  af]
	rts                                    	| [$24e8: ret]
l_24e9:
	move.b	#0x02,d0                        	| [$24e9: ld   a,$02]
	lea	l_9840(pc),a0                      	| [$24eb: ld   hl,$9840]
	jbsr	l_5605                            	| [$24ee: call $5605]
	rts                                    	| [$24f1: ret]
l_24f2:
	jbsr	get_XUP_screen_address_2501                            	| [$24f2: call $2501]
	lea	game_mem+0x576C,a1                      	| [$24f5: ld   de,$576C]
	jbsr	l_30f9                            	| [$24f8: call $30F9]
	clr.b	d0                               	| [$24fb: xor  a]
	move.b	d0,unknown_626E                 	| [$24fc: ld   (unknown_626E),a]
	move.w	(sp)+,d0                        	| [$24ff: pop  af]
	rts                                    	| [$2500: ret]
get_XUP_screen_address_2501:
	move.b	current_player_617C,d0          	| [$2501: ld   a,(current_player_617C)]
	move.w	#0x93A0,d6                     	| [$2504: ld   hl,$93A0]
	cmp.b	#0x01,d0                         	| [$2507: cp   $01]
	beq.b	0f
	rts                                    	| [$2509: ret  nz]
0:
	move.w	#0x9120,d6                     	| [$250a: ld   hl,$9120]
	rts                                    	| [$250d: ret]

l_29cb:
	move.b	#0x08,d1                        	| [$29cb: ld   b,$08]
	* clear ram
	lea	number_of_credits_6000,a0      	| [$29cd: ld   hl,number_of_credits_6000]
l_29d0:
	clr.b	d0                               	| [$29d0: xor  a]
l_29d1:
	move.b	d0,d2                           	| [$29d1: ld   c,a]
l_29d2:
	move.b	d0,(a0)+                         	| [$29d2: ld   (hl),a]
											| [$29d3: inc  hl]
	subq.b	#1,d2                           	| [$29d4: dec  c]
	jne	l_29d2                             	| [$29d5: jr   nz,$29D2]
	subq.b	#1,d1                           	| [...]
	jne	l_29d1                             	| [$29d7: djnz $29D1]
	jra	l_2483                             	| [$29d9: jp   $2483]

	* game part
	.ifdef	XXXXXX
l_29dc:
	move.b	#0x08,d1                        	| [$29dc: ld   b,$08]
	lea	number_of_credits_6000(pc),a0      	| [$29de: ld   hl,number_of_credits_6000]
l_29e1:
	move.b	d0,d2                           	| [$29e1: ld   c,a]
l_29e2:
	move.b	d0,(a0)                         	| [$29e2: ld   (hl),a]
	addq.w	#1,a0                           	| [$29e3: inc  hl]
	subq.b	#1,d2                           	| [$29e4: dec  c]
	jne	l_29e2                             	| [$29e5: jr   nz,$29E2]
	subq.b	#1,d1                           	| [...]
	jne	l_29e1                             	| [$29e7: djnz $29E1]
	jra	l_2486                             	| [$29e9: jp   $2486]
l_29ec:
	move.b	#0x08,d1                        	| [$29ec: ld   b,$08]
	lea	l_9800(pc),a0                      	| [$29ee: ld   hl,$9800]
l_29f1:
	clr.b	d2                               	| [$29f1: ld   c,$00]
l_29f3:
	move.b	d0,(a0)                         	| [$29f3: ld   (hl),a]
	addq.w	#1,a0                           	| [$29f4: inc  hl]
	move.w	d0,-(sp)                        	| [$29f5: push af]
	move.b	io_read_shit_B800,d0            	| [$29f6: ld   a,(io_read_shit_B800)]
	move.w	(sp)+,d0                        	| [$29f9: pop  af]
	subq.b	#1,d2                           	| [$29fa: dec  c]
	jne	l_29f3                             	| [$29fb: jr   nz,$29F3]
	subq.b	#1,d1                           	| [...]
	jne	l_29f1                             	| [$29fd: djnz $29F1]
	rts                                    	| [$29ff: ret]
l_2a00:
	move.b	#0x04,d1                        	| [$2a00: ld   b,$04]
	move.b	#0xE0,d0                        	| [$2a02: ld   a,$E0]
	lea	l_9000(pc),a0                      	| [$2a04: ld   hl,$9000]
l_2a07:
	clr.b	d2                               	| [$2a07: ld   c,$00]
l_2a09:
	move.b	d0,(a0)                         	| [$2a09: ld   (hl),a]
	addq.w	#1,a0                           	| [$2a0a: inc  hl]
	move.w	d0,-(sp)                        	| [$2a0b: push af]
	move.b	io_read_shit_B800,d0            	| [$2a0c: ld   a,(io_read_shit_B800)]
	move.w	(sp)+,d0                        	| [$2a0f: pop  af]
	subq.b	#1,d2                           	| [$2a10: dec  c]
	jne	l_2a09                             	| [$2a11: jr   nz,$2A09]
	subq.b	#1,d1                           	| [...]
	jne	l_2a07                             	| [$2a13: djnz $2A07]
	rts                                    	| [$2a15: ret]
l_2a16:
	move.b	#0xE0,d0                        	| [$2a16: ld   a,$E0]
	move.b	#0xE0,d0                        	| [$2a18: ld   a,$E0]
	lea	l_93E4(pc),a0                      	| [$2a1a: ld   hl,$93E4]
	move.b	#0x1B,d1                        	| [$2a1d: ld   b,$1B]
l_2a1f:

	move.l	a0,-(sp)                        	| [$2a1f: push hl]
	movem.w	d1/d2,-(sp)                    	| [$2a20: push bc]
	move.b	#0x20,d1                        	| [$2a21: ld   b,$20]
	jbsr	l_29bc                            	| [$2a23: call $29BC]

	movem.w	(sp)+,d1/d2                    	| [$2a26: pop  bc]
	move.l	(sp)+,a0                        	| [$2a27: pop  hl]
	addq.w	#1,a0                           	| [$2a28: inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_2a1f                             	| [$2a29: djnz $2A1F]
	rts                                    	| [$2a2b: ret]
l_2a2c:
*	clr.b	d0                               	| [$2a2c: ld   a,$00]
*	move.b	d0,0xA003                       	| [$2a2e: ld   ($A003),a]
	move.b	#0x04,d1                        	| [$2a31: ld   b,$04]
	move.b	#0xE0,d0                        	| [$2a33: ld   a,$E0]
	lea	l_9000(pc),a0                      	| [$2a35: ld   hl,$9000]
	jbsr	l_2a07                            	| [$2a38: call $2A07]
	move.b	#0x3F,d0                        	| [$2a3b: ld   a,$3F]
	jbsr	l_29ec                            	| [$2a3d: call $29EC]
	move.b	0x628C,d0                       	| [$2a40: ld   a,($628C)]
	cmp.b	#0x01,d0                         	| [$2a43: cp   $01]
	jeq	l_2a50                             	| [$2a45: jr   z,$2A50]
	lea	game_mem+0x56C3,a1                      	| [$2a47: ld   de,$56C3]
	* write something to screens
	move.lw	#0x93AF,d6                      	| [$2a4a: ld   hl,$93AF]
	jbsr	l_30f9                            	| [$2a4d: call $30F9]
l_2a50:
	move.b	#0x01,d1                        	| [$2a50: ld   b,$01]
	lea	player_struct_6580,a0          	| [$2a52: ld   hl,player_struct_6580]
	clr.b	d0                               	| [$2a55: ld   a,$00]
	jbsr	l_29f1                            	| [$2a57: call $29F1]
	jbsr	l_3110                            	| [$2a5a: call $3110]
	* video enable
*	move.b	#0x01,d0                        	| [$2a5d: ld   a,$01]
*	move.b	d0,0xA003                       	| [$2a5f: ld   ($A003),a]
	rts                                    	| [$2a62: ret]
l_2a63:
	lea	unknown_6176,a2                      	| [$2a63: ld   ix,$6176]
	move.b	#0x07,d1                        	| [$2a67: ld   b,$07]
	clr.b	d0                               	| [$2a69: xor  a]
l_2a6a:
	nop                                    	| [$2a6a: nop]
	addq.w	#1,a2                           	| [$2a6b: inc  ix]
	subq.b	#1,d1                           	| [...]
	jne	l_2a6a                             	| [$2a6d: djnz $2A6A]
	rts                                    	| [$2a6f: ret]
l_2a70:
	* cocktail mode?
*	move.b	unknown_6163,d0                       	| [$2a70: ld   a,($6163)]
*	and.b	#0x80,d0                         	| [$2a73: and  $80]
*	cmp.b	#0x00,d0                         	| [$2a75: cp   $00]
*	jeq	l_2a85                             	| [$2a77: jr   z,$2A85]
*	move.b	current_player_617C,d0          	| [$2a79: ld   a,(current_player_617C)]
*	not.b	d0                               	| [$2a7c: cpl]
*	and.b	#0x01,d0                         	| [$2a7d: and  $01]
*	move.b	d0,0xA001                       	| [$2a7f: ld   ($A001),a]
*	move.b	d0,0xA002                       	| [$2a82: ld   ($A002),a]
*l_2a85:
	lea	unknown_609C,a2                      	| [$2a85: ld   ix,$609C]
	lea	unknown_617F,a3                      	| [$2a89: ld   iy,$617F]
	move.b	#0x36,d1                        	| [$2a8d: ld   b,$36]
	jbsr	l_2abc                            	| [$2a8f: call $2ABC]
	lea	unknown_61C4,a2                      	| [$2a92: ld   ix,$61C4]
	lea	unknown_61FA,a3                      	| [$2a96: ld   iy,$61FA]
	move.b	#0x03,d1                        	| [$2a9a: ld   b,$03]
	jbsr	l_2abc                            	| [$2a9c: call $2ABC]
	move.b	lives_6056,d0                   	| [$2a9f: ld   a,(lives_6056)]
	move.w	d0,-(sp)                        	| [$2aa2: push af]
	move.b	unknown_617E,d0                       	| [$2aa3: ld   a,($617E)]
	move.b	d0,lives_6056                   	| [$2aa6: ld   (lives_6056),a]
	move.w	(sp)+,d0                        	| [$2aa9: pop  af]
	move.b	d0,unknown_617E                       	| [$2aaa: ld   ($617E),a]
	move.b	unknown_6290,d0                       	| [$2aad: ld   a,($6290)]
	move.w	d0,-(sp)                        	| [$2ab0: push af]
	move.b	unknown_627D,d0                       	| [$2ab1: ld   a,($627D)]
	move.b	d0,unknown_6290                       	| [$2ab4: ld   ($6290),a]
	move.w	(sp)+,d0                        	| [$2ab7: pop  af]
	move.b	d0,unknown_627D                       	| [$2ab8: ld   ($627D),a]
	rts                                    	| [$2abb: ret]
l_2abc:
	move.b	(0x00,a2),d0                    	| [$2abc: ld   a,(ix+$00)]
	move.w	d0,-(sp)                        	| [$2abf: push af]
	move.b	(0x00,a3),d0                    	| [$2ac0: ld   a,(iy+$00)]
	move.b	d0,(0x00,a2)                    	| [$2ac3: ld   (ix+$00),a]
	move.w	(sp)+,d0                        	| [$2ac6: pop  af]
	move.b	d0,(0x00,a3)                    	| [$2ac7: ld   (iy+$00),a]
	addq.w	#1,a2                           	| [$2aca: inc  ix]
	addq.w	#1,a3                           	| [$2acc: inc  iy]
	subq.b	#1,d1                           	| [...]
	jne	l_2abc                             	| [$2ace: djnz $2ABC]
	rts                                    	| [$2ad0: ret]
	.endif
	
	
